{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"l33tcode Solutions for JD Pierce Path-Crossing Problem https://leetcode.com/problems/path-crossing Solution Finding 3-Digit Even Numbers https://leetcode.com/problems/finding-3-digit-even-numbers Solution","title":"l33tcode Solutions for JD Pierce"},{"location":"#l33tcode-solutions-for-jd-pierce","text":"","title":"l33tcode Solutions for JD Pierce"},{"location":"#path-crossing-problem","text":"https://leetcode.com/problems/path-crossing Solution","title":"Path-Crossing Problem"},{"location":"#finding-3-digit-even-numbers","text":"https://leetcode.com/problems/finding-3-digit-even-numbers Solution","title":"Finding 3-Digit Even Numbers"},{"location":"Finding3DigitEvenNumbers/","text":"[https://leetcode.com/problems/path-crossing https://leetcode.com/problems/finding-3-digit-even-numbers Intuition My first thought was to use a sliding window to find all of the possible 3 digit groupings, then separately find each possible permutation of numbers within each grouping. This flawed first thinking stemmed from one issue off the get-go: I did NOT read the problem thorougly enough and thus I thought each group of 3 numbers had to be next to each other (consecutive). However, I later realized you could group any 3 numbers regardless of proximity, which later gave rise to the ReduceDigits() method which allows the solution to run somewhat performately. Approach Reduce digits to a maximum of 3 of each digit (3 0's, 3 1's, etc.) Find all possible unique groupings of 3 digits from the pool Check for leading zero Check last digit is even Return all even numbers that have passed all criteria Complexity Time complexity: Essentially O(n) but it's a bit of a complicated calculation - note there is an aboslute maximum of n=30 (3*10) Space complexity: Also should be linear, so O(n) Code class TupleComparer : IEqualityComparer<Tuple<int,int,int>> { public bool Equals(Tuple<int,int,int> x, Tuple<int,int,int> y) { var x_ordered = new List<int>(){x.Item1, x.Item2, x.Item3}; x_ordered.Sort(); var y_ordered = new List<int>(){y.Item1, y.Item2, y.Item3}; y_ordered.Sort(); return x_ordered[0] == y_ordered[0] && x_ordered[1] == y_ordered[1] && x_ordered[2] == y_ordered[2]; } public int GetHashCode(Tuple<int,int,int> source) { int hash = 0; hash = hash ^ source.Item1.GetHashCode(); hash = hash ^ source.Item2.GetHashCode(); hash = hash ^ source.Item3.GetHashCode(); return hash; } } public class Solution { public void GetPermutations(Tuple<int,int,int> digits, ref HashSet<int> hashes) { if(digits.Item1 != 0) { if(digits.Item3 % 2 == 0) hashes.Add(digits.Item1 * 100 + digits.Item2 * 10 + digits.Item3); if(digits.Item2 % 2 == 0) hashes.Add(digits.Item1 * 100 + digits.Item3 * 10 + digits.Item2); } if(digits.Item2 != 0) { if(digits.Item3 % 2 == 0) hashes.Add(digits.Item2 * 100 + digits.Item1 * 10 + digits.Item3); if(digits.Item1 % 2 == 0) hashes.Add(digits.Item2 * 100 + digits.Item3 * 10 + digits.Item1); } if(digits.Item3 != 0) { if(digits.Item2 % 2 == 0) hashes.Add(digits.Item3 * 100 + digits.Item1 * 10 + digits.Item2); if(digits.Item1 % 2 == 0) hashes.Add(digits.Item3 * 100 + digits.Item2 * 10 + digits.Item1); } } public HashSet<Tuple<int,int,int>> GetGroups(int[] digits) { HashSet<Tuple<int,int,int>> hashes = new HashSet<Tuple<int,int,int>>(new TupleComparer()); for(int i=0; i<digits.Length; i++) { var item1 = digits[i]; for(int j=0; j<digits.Length; j++) { if(i==j) continue; var item2 = digits[j]; for(int k=0; k<digits.Length; k++) { if(i==k || j==k) continue; var item3 = digits[k]; Tuple<int,int,int> group = new Tuple<int,int,int>(item1, item2, item3); hashes.Add(group); } } } return hashes; } int[] ReduceDigits(int[] digits) { List<int> new_digits = new List<int>(); for(int i=0; i<10; i++) { int count = digits.Count(d => d==i); for(int j=0; j<count && j<=3; j++) { new_digits.Add(i); } } return new_digits.ToArray(); } public int[] FindEvenNumbers(int[] digits) { var new_digits = ReduceDigits(digits); var groups = GetGroups(new_digits); Console.WriteLine($\"Found {groups.Count()} groups:\"); foreach(var group in groups) Console.WriteLine($\"{group.Item1}{group.Item2}{group.Item3}\"); HashSet<int> evenNums = new HashSet<int>(); foreach(var group in groups) { GetPermutations(group, ref evenNums); } var result = evenNums.ToList(); result.Sort(); return result.ToArray(); } }","title":"Finding3DigitEvenNumbers"},{"location":"Finding3DigitEvenNumbers/#intuition","text":"My first thought was to use a sliding window to find all of the possible 3 digit groupings, then separately find each possible permutation of numbers within each grouping. This flawed first thinking stemmed from one issue off the get-go: I did NOT read the problem thorougly enough and thus I thought each group of 3 numbers had to be next to each other (consecutive). However, I later realized you could group any 3 numbers regardless of proximity, which later gave rise to the ReduceDigits() method which allows the solution to run somewhat performately.","title":"Intuition"},{"location":"Finding3DigitEvenNumbers/#approach","text":"Reduce digits to a maximum of 3 of each digit (3 0's, 3 1's, etc.) Find all possible unique groupings of 3 digits from the pool Check for leading zero Check last digit is even Return all even numbers that have passed all criteria","title":"Approach"},{"location":"Finding3DigitEvenNumbers/#complexity","text":"Time complexity: Essentially O(n) but it's a bit of a complicated calculation - note there is an aboslute maximum of n=30 (3*10) Space complexity: Also should be linear, so O(n)","title":"Complexity"},{"location":"Finding3DigitEvenNumbers/#code","text":"class TupleComparer : IEqualityComparer<Tuple<int,int,int>> { public bool Equals(Tuple<int,int,int> x, Tuple<int,int,int> y) { var x_ordered = new List<int>(){x.Item1, x.Item2, x.Item3}; x_ordered.Sort(); var y_ordered = new List<int>(){y.Item1, y.Item2, y.Item3}; y_ordered.Sort(); return x_ordered[0] == y_ordered[0] && x_ordered[1] == y_ordered[1] && x_ordered[2] == y_ordered[2]; } public int GetHashCode(Tuple<int,int,int> source) { int hash = 0; hash = hash ^ source.Item1.GetHashCode(); hash = hash ^ source.Item2.GetHashCode(); hash = hash ^ source.Item3.GetHashCode(); return hash; } } public class Solution { public void GetPermutations(Tuple<int,int,int> digits, ref HashSet<int> hashes) { if(digits.Item1 != 0) { if(digits.Item3 % 2 == 0) hashes.Add(digits.Item1 * 100 + digits.Item2 * 10 + digits.Item3); if(digits.Item2 % 2 == 0) hashes.Add(digits.Item1 * 100 + digits.Item3 * 10 + digits.Item2); } if(digits.Item2 != 0) { if(digits.Item3 % 2 == 0) hashes.Add(digits.Item2 * 100 + digits.Item1 * 10 + digits.Item3); if(digits.Item1 % 2 == 0) hashes.Add(digits.Item2 * 100 + digits.Item3 * 10 + digits.Item1); } if(digits.Item3 != 0) { if(digits.Item2 % 2 == 0) hashes.Add(digits.Item3 * 100 + digits.Item1 * 10 + digits.Item2); if(digits.Item1 % 2 == 0) hashes.Add(digits.Item3 * 100 + digits.Item2 * 10 + digits.Item1); } } public HashSet<Tuple<int,int,int>> GetGroups(int[] digits) { HashSet<Tuple<int,int,int>> hashes = new HashSet<Tuple<int,int,int>>(new TupleComparer()); for(int i=0; i<digits.Length; i++) { var item1 = digits[i]; for(int j=0; j<digits.Length; j++) { if(i==j) continue; var item2 = digits[j]; for(int k=0; k<digits.Length; k++) { if(i==k || j==k) continue; var item3 = digits[k]; Tuple<int,int,int> group = new Tuple<int,int,int>(item1, item2, item3); hashes.Add(group); } } } return hashes; } int[] ReduceDigits(int[] digits) { List<int> new_digits = new List<int>(); for(int i=0; i<10; i++) { int count = digits.Count(d => d==i); for(int j=0; j<count && j<=3; j++) { new_digits.Add(i); } } return new_digits.ToArray(); } public int[] FindEvenNumbers(int[] digits) { var new_digits = ReduceDigits(digits); var groups = GetGroups(new_digits); Console.WriteLine($\"Found {groups.Count()} groups:\"); foreach(var group in groups) Console.WriteLine($\"{group.Item1}{group.Item2}{group.Item3}\"); HashSet<int> evenNums = new HashSet<int>(); foreach(var group in groups) { GetPermutations(group, ref evenNums); } var result = evenNums.ToList(); result.Sort(); return result.ToArray(); } }","title":"Code"},{"location":"PathCrossing/","text":"https://leetcode.com/problems/path-crossing Intuition Implement an unoptimized solution by just recording each traveled node. NOTE: after a ton of analysis of the proposed solutions on l33tcode, I can confirm that this solution is actually quite well optimized - there does not seem to be a trick capable of detecting a crossing without recording each and every position Approach Record each traveled node by combining X and Y into a single number and store in a HashSet Iterate through all characters in the array until a previously traveled node is encountered, then exit. Complexity Time complexity: O(n) (iterate through each position once) Space complexity: O(n) (store each position as hash) Code public class Solution { class PointComparer : IEqualityComparer<System.Drawing.Point> { public bool Equals(System.Drawing.Point x, System.Drawing.Point y) { return x.X == y.X && x.Y == y.Y; } public int GetHashCode(System.Drawing.Point obj) { return (obj.Y << 16) ^ obj.X; } } private HashSet<System.Drawing.Point> hashes = new HashSet<System.Drawing.Point>(new PointComparer()); private System.Drawing.Point currentPos = new System.Drawing.Point(0,0); private bool OccupyCurrentPos() { //Console.WriteLine($\"Calculated hash {hash} for position {currentPos.X}, {currentPos.Y}\"); if(hashes.Contains(currentPos)) return true; hashes.Add(currentPos); return false; } public bool IsPathCrossing(string path) { OccupyCurrentPos(); foreach(char c in path.ToLower()) { switch(c) { case 'n': currentPos.Y++; break; case 's': currentPos.Y--; break; case 'e': currentPos.X++; break; case 'w': currentPos.X--; break; } if(OccupyCurrentPos()) { //Console.WriteLine($\"Crossed at {currentPos.X},{currentPos.Y}\"); return true; } } return false; } }","title":"PathCrossing"},{"location":"PathCrossing/#intuition","text":"Implement an unoptimized solution by just recording each traveled node. NOTE: after a ton of analysis of the proposed solutions on l33tcode, I can confirm that this solution is actually quite well optimized - there does not seem to be a trick capable of detecting a crossing without recording each and every position","title":"Intuition"},{"location":"PathCrossing/#approach","text":"Record each traveled node by combining X and Y into a single number and store in a HashSet Iterate through all characters in the array until a previously traveled node is encountered, then exit.","title":"Approach"},{"location":"PathCrossing/#complexity","text":"Time complexity: O(n) (iterate through each position once) Space complexity: O(n) (store each position as hash)","title":"Complexity"},{"location":"PathCrossing/#code","text":"public class Solution { class PointComparer : IEqualityComparer<System.Drawing.Point> { public bool Equals(System.Drawing.Point x, System.Drawing.Point y) { return x.X == y.X && x.Y == y.Y; } public int GetHashCode(System.Drawing.Point obj) { return (obj.Y << 16) ^ obj.X; } } private HashSet<System.Drawing.Point> hashes = new HashSet<System.Drawing.Point>(new PointComparer()); private System.Drawing.Point currentPos = new System.Drawing.Point(0,0); private bool OccupyCurrentPos() { //Console.WriteLine($\"Calculated hash {hash} for position {currentPos.X}, {currentPos.Y}\"); if(hashes.Contains(currentPos)) return true; hashes.Add(currentPos); return false; } public bool IsPathCrossing(string path) { OccupyCurrentPos(); foreach(char c in path.ToLower()) { switch(c) { case 'n': currentPos.Y++; break; case 's': currentPos.Y--; break; case 'e': currentPos.X++; break; case 'w': currentPos.X--; break; } if(OccupyCurrentPos()) { //Console.WriteLine($\"Crossed at {currentPos.X},{currentPos.Y}\"); return true; } } return false; } }","title":"Code"},{"location":"TotalCharactersInStringAfterTransformations/","text":"https://leetcode.com/problems/total-characters-in-string-after-transformations-i Intuition My first intuition was that I could determine the output of a given letter after t iterations, independent of the other letters. (I was wrong) Approach My first approach was to try and use a combination of modulus and dividing the iteration count t by 26 to determine the end result of each letter. The goal here was to NOT iterate through t and aim for a fixed complexity rather than O(n) . In the end I found the branching logic too difficult for high iterations of t . With high enough iterations, a single letter would spawn many other letters and I could not capture this logic with a math equation. Secondly I tried counting all the letters and putting them into buckets., then performing a similar pass as previously discussed. This also did not work. Finally, after peeking at the answer, I resigned to iterating through t for O(n) complexity. I broke-down and re-wrote the answer in order to fully understand it. In the end I still wonder if there is a calculation which could capture the end state after t transformations of even a single letter, without having to \"perform the simulation\" by iterating over t . Complexity Time complexity: O(n) Space complexity: Whatever 26 letters take up + the supporting code. Fixed cost. Code public class Solution { private const int MOD = 1000000007; public ulong[] CountChars(string s) { ulong[] char_counts = new ulong[26]; foreach (char ch in s) char_counts[ch - 'a']++; return char_counts; } public int LengthAfterTransformations(string s, int t) { var char_counts = CountChars(s); /* deciphered from https://leetcode.com/problems/total-characters-in-string-after-transformations-i/?envType=daily-question&envId=2025-05-13 this solution cleverly defines letter counts based on where they could COME FROM, rather than what each letter is CONVERTED TO ...'a' can come from 'z' ...'b' can come from 'z' or 'a' ...others chars can come from their previous char this allows for a very clear formulaic approach ----------- however, it is not possible to determine all yields of a given letter and number of steps. ...for example, if provided the only input string of letter 'a' but a long number of steps 't', ...it's still difficult to determine the result ... therefore, it IS actually necessary to step through each iteration (via 't') (oh and dont forget to apply modulator to reduce number size) */ for (ulong i = 0; i < (ulong)t; ++i) { ulong[] next_counts = new ulong[26]; // 'a' only comes from 'z' next_counts[0] = char_counts[25]; // 'b' comes from 'a' and 'z' next_counts[1] = (char_counts[25] + char_counts[0]) % MOD; // remaining letters come from their previous for (ulong j = 2; j < 26; ++j) next_counts[j] = char_counts[j - 1] % MOD; char_counts = next_counts; } return (int)(char_counts.Aggregate((x,y) =>(x+y) % MOD)); } }","title":"TotalCharactersInStringAfterTransformations"},{"location":"TotalCharactersInStringAfterTransformations/#intuition","text":"My first intuition was that I could determine the output of a given letter after t iterations, independent of the other letters. (I was wrong)","title":"Intuition"},{"location":"TotalCharactersInStringAfterTransformations/#approach","text":"My first approach was to try and use a combination of modulus and dividing the iteration count t by 26 to determine the end result of each letter. The goal here was to NOT iterate through t and aim for a fixed complexity rather than O(n) . In the end I found the branching logic too difficult for high iterations of t . With high enough iterations, a single letter would spawn many other letters and I could not capture this logic with a math equation. Secondly I tried counting all the letters and putting them into buckets., then performing a similar pass as previously discussed. This also did not work. Finally, after peeking at the answer, I resigned to iterating through t for O(n) complexity. I broke-down and re-wrote the answer in order to fully understand it. In the end I still wonder if there is a calculation which could capture the end state after t transformations of even a single letter, without having to \"perform the simulation\" by iterating over t .","title":"Approach"},{"location":"TotalCharactersInStringAfterTransformations/#complexity","text":"Time complexity: O(n) Space complexity: Whatever 26 letters take up + the supporting code. Fixed cost.","title":"Complexity"},{"location":"TotalCharactersInStringAfterTransformations/#code","text":"public class Solution { private const int MOD = 1000000007; public ulong[] CountChars(string s) { ulong[] char_counts = new ulong[26]; foreach (char ch in s) char_counts[ch - 'a']++; return char_counts; } public int LengthAfterTransformations(string s, int t) { var char_counts = CountChars(s); /* deciphered from https://leetcode.com/problems/total-characters-in-string-after-transformations-i/?envType=daily-question&envId=2025-05-13 this solution cleverly defines letter counts based on where they could COME FROM, rather than what each letter is CONVERTED TO ...'a' can come from 'z' ...'b' can come from 'z' or 'a' ...others chars can come from their previous char this allows for a very clear formulaic approach ----------- however, it is not possible to determine all yields of a given letter and number of steps. ...for example, if provided the only input string of letter 'a' but a long number of steps 't', ...it's still difficult to determine the result ... therefore, it IS actually necessary to step through each iteration (via 't') (oh and dont forget to apply modulator to reduce number size) */ for (ulong i = 0; i < (ulong)t; ++i) { ulong[] next_counts = new ulong[26]; // 'a' only comes from 'z' next_counts[0] = char_counts[25]; // 'b' comes from 'a' and 'z' next_counts[1] = (char_counts[25] + char_counts[0]) % MOD; // remaining letters come from their previous for (ulong j = 2; j < 26; ++j) next_counts[j] = char_counts[j - 1] % MOD; char_counts = next_counts; } return (int)(char_counts.Aggregate((x,y) =>(x+y) % MOD)); } }","title":"Code"}]}