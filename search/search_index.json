{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"l33tcode Solutions for JD Pierce Path-Crossing Problem https://leetcode.com/problems/path-crossing Solution Finding 3-Digit Even Numbers https://leetcode.com/problems/finding-3-digit-even-numbers Solution Total Characters in String After Transformations https://leetcode.com/problems/total-characters-in-string-after-transformations-i Solution Total Characters in String After Transformations https://leetcode.com/problems/set-matrix-zeroes Solution","title":"l33tcode Solutions for JD Pierce"},{"location":"#l33tcode-solutions-for-jd-pierce","text":"","title":"l33tcode Solutions for JD Pierce"},{"location":"#path-crossing-problem","text":"https://leetcode.com/problems/path-crossing Solution","title":"Path-Crossing Problem"},{"location":"#finding-3-digit-even-numbers","text":"https://leetcode.com/problems/finding-3-digit-even-numbers Solution","title":"Finding 3-Digit Even Numbers"},{"location":"#total-characters-in-string-after-transformations","text":"https://leetcode.com/problems/total-characters-in-string-after-transformations-i Solution","title":"Total Characters in String After Transformations"},{"location":"#total-characters-in-string-after-transformations_1","text":"https://leetcode.com/problems/set-matrix-zeroes Solution","title":"Total Characters in String After Transformations"},{"location":"Finding3DigitEvenNumbers/","text":"[https://leetcode.com/problems/path-crossing https://leetcode.com/problems/finding-3-digit-even-numbers Intuition My first thought was to use a sliding window to find all of the possible 3 digit groupings, then separately find each possible permutation of numbers within each grouping. This flawed first thinking stemmed from one issue off the get-go: I did NOT read the problem thorougly enough and thus I thought each group of 3 numbers had to be next to each other (consecutive). However, I later realized you could group any 3 numbers regardless of proximity, which later gave rise to the ReduceDigits() method which allows the solution to run somewhat performately. Approach Reduce digits to a maximum of 3 of each digit (3 0's, 3 1's, etc.) Find all possible unique groupings of 3 digits from the pool Check for leading zero Check last digit is even Return all even numbers that have passed all criteria Complexity Time complexity: Essentially O(n) but it's a bit of a complicated calculation - note there is an aboslute maximum of n=30 (3*10) Space complexity: Also should be linear, so O(n) Code class TupleComparer : IEqualityComparer<Tuple<int,int,int>> { public bool Equals(Tuple<int,int,int> x, Tuple<int,int,int> y) { var x_ordered = new List<int>(){x.Item1, x.Item2, x.Item3}; x_ordered.Sort(); var y_ordered = new List<int>(){y.Item1, y.Item2, y.Item3}; y_ordered.Sort(); return x_ordered[0] == y_ordered[0] && x_ordered[1] == y_ordered[1] && x_ordered[2] == y_ordered[2]; } public int GetHashCode(Tuple<int,int,int> source) { int hash = 0; hash = hash ^ source.Item1.GetHashCode(); hash = hash ^ source.Item2.GetHashCode(); hash = hash ^ source.Item3.GetHashCode(); return hash; } } public class Solution { public void GetPermutations(Tuple<int,int,int> digits, ref HashSet<int> hashes) { if(digits.Item1 != 0) { if(digits.Item3 % 2 == 0) hashes.Add(digits.Item1 * 100 + digits.Item2 * 10 + digits.Item3); if(digits.Item2 % 2 == 0) hashes.Add(digits.Item1 * 100 + digits.Item3 * 10 + digits.Item2); } if(digits.Item2 != 0) { if(digits.Item3 % 2 == 0) hashes.Add(digits.Item2 * 100 + digits.Item1 * 10 + digits.Item3); if(digits.Item1 % 2 == 0) hashes.Add(digits.Item2 * 100 + digits.Item3 * 10 + digits.Item1); } if(digits.Item3 != 0) { if(digits.Item2 % 2 == 0) hashes.Add(digits.Item3 * 100 + digits.Item1 * 10 + digits.Item2); if(digits.Item1 % 2 == 0) hashes.Add(digits.Item3 * 100 + digits.Item2 * 10 + digits.Item1); } } public HashSet<Tuple<int,int,int>> GetGroups(int[] digits) { HashSet<Tuple<int,int,int>> hashes = new HashSet<Tuple<int,int,int>>(new TupleComparer()); for(int i=0; i<digits.Length; i++) { var item1 = digits[i]; for(int j=0; j<digits.Length; j++) { if(i==j) continue; var item2 = digits[j]; for(int k=0; k<digits.Length; k++) { if(i==k || j==k) continue; var item3 = digits[k]; Tuple<int,int,int> group = new Tuple<int,int,int>(item1, item2, item3); hashes.Add(group); } } } return hashes; } int[] ReduceDigits(int[] digits) { List<int> new_digits = new List<int>(); for(int i=0; i<10; i++) { int count = digits.Count(d => d==i); for(int j=0; j<count && j<=3; j++) { new_digits.Add(i); } } return new_digits.ToArray(); } public int[] FindEvenNumbers(int[] digits) { var new_digits = ReduceDigits(digits); var groups = GetGroups(new_digits); Console.WriteLine($\"Found {groups.Count()} groups:\"); foreach(var group in groups) Console.WriteLine($\"{group.Item1}{group.Item2}{group.Item3}\"); HashSet<int> evenNums = new HashSet<int>(); foreach(var group in groups) { GetPermutations(group, ref evenNums); } var result = evenNums.ToList(); result.Sort(); return result.ToArray(); } }","title":"Finding3DigitEvenNumbers"},{"location":"Finding3DigitEvenNumbers/#intuition","text":"My first thought was to use a sliding window to find all of the possible 3 digit groupings, then separately find each possible permutation of numbers within each grouping. This flawed first thinking stemmed from one issue off the get-go: I did NOT read the problem thorougly enough and thus I thought each group of 3 numbers had to be next to each other (consecutive). However, I later realized you could group any 3 numbers regardless of proximity, which later gave rise to the ReduceDigits() method which allows the solution to run somewhat performately.","title":"Intuition"},{"location":"Finding3DigitEvenNumbers/#approach","text":"Reduce digits to a maximum of 3 of each digit (3 0's, 3 1's, etc.) Find all possible unique groupings of 3 digits from the pool Check for leading zero Check last digit is even Return all even numbers that have passed all criteria","title":"Approach"},{"location":"Finding3DigitEvenNumbers/#complexity","text":"Time complexity: Essentially O(n) but it's a bit of a complicated calculation - note there is an aboslute maximum of n=30 (3*10) Space complexity: Also should be linear, so O(n)","title":"Complexity"},{"location":"Finding3DigitEvenNumbers/#code","text":"class TupleComparer : IEqualityComparer<Tuple<int,int,int>> { public bool Equals(Tuple<int,int,int> x, Tuple<int,int,int> y) { var x_ordered = new List<int>(){x.Item1, x.Item2, x.Item3}; x_ordered.Sort(); var y_ordered = new List<int>(){y.Item1, y.Item2, y.Item3}; y_ordered.Sort(); return x_ordered[0] == y_ordered[0] && x_ordered[1] == y_ordered[1] && x_ordered[2] == y_ordered[2]; } public int GetHashCode(Tuple<int,int,int> source) { int hash = 0; hash = hash ^ source.Item1.GetHashCode(); hash = hash ^ source.Item2.GetHashCode(); hash = hash ^ source.Item3.GetHashCode(); return hash; } } public class Solution { public void GetPermutations(Tuple<int,int,int> digits, ref HashSet<int> hashes) { if(digits.Item1 != 0) { if(digits.Item3 % 2 == 0) hashes.Add(digits.Item1 * 100 + digits.Item2 * 10 + digits.Item3); if(digits.Item2 % 2 == 0) hashes.Add(digits.Item1 * 100 + digits.Item3 * 10 + digits.Item2); } if(digits.Item2 != 0) { if(digits.Item3 % 2 == 0) hashes.Add(digits.Item2 * 100 + digits.Item1 * 10 + digits.Item3); if(digits.Item1 % 2 == 0) hashes.Add(digits.Item2 * 100 + digits.Item3 * 10 + digits.Item1); } if(digits.Item3 != 0) { if(digits.Item2 % 2 == 0) hashes.Add(digits.Item3 * 100 + digits.Item1 * 10 + digits.Item2); if(digits.Item1 % 2 == 0) hashes.Add(digits.Item3 * 100 + digits.Item2 * 10 + digits.Item1); } } public HashSet<Tuple<int,int,int>> GetGroups(int[] digits) { HashSet<Tuple<int,int,int>> hashes = new HashSet<Tuple<int,int,int>>(new TupleComparer()); for(int i=0; i<digits.Length; i++) { var item1 = digits[i]; for(int j=0; j<digits.Length; j++) { if(i==j) continue; var item2 = digits[j]; for(int k=0; k<digits.Length; k++) { if(i==k || j==k) continue; var item3 = digits[k]; Tuple<int,int,int> group = new Tuple<int,int,int>(item1, item2, item3); hashes.Add(group); } } } return hashes; } int[] ReduceDigits(int[] digits) { List<int> new_digits = new List<int>(); for(int i=0; i<10; i++) { int count = digits.Count(d => d==i); for(int j=0; j<count && j<=3; j++) { new_digits.Add(i); } } return new_digits.ToArray(); } public int[] FindEvenNumbers(int[] digits) { var new_digits = ReduceDigits(digits); var groups = GetGroups(new_digits); Console.WriteLine($\"Found {groups.Count()} groups:\"); foreach(var group in groups) Console.WriteLine($\"{group.Item1}{group.Item2}{group.Item3}\"); HashSet<int> evenNums = new HashSet<int>(); foreach(var group in groups) { GetPermutations(group, ref evenNums); } var result = evenNums.ToList(); result.Sort(); return result.ToArray(); } }","title":"Code"},{"location":"PathCrossing/","text":"https://leetcode.com/problems/path-crossing Intuition Implement an unoptimized solution by just recording each traveled node. NOTE: after a ton of analysis of the proposed solutions on l33tcode, I can confirm that this solution is actually quite well optimized - there does not seem to be a trick capable of detecting a crossing without recording each and every position Approach Record each traveled node by combining X and Y into a single number and store in a HashSet Iterate through all characters in the array until a previously traveled node is encountered, then exit. Complexity Time complexity: O(n) (iterate through each position once) Space complexity: O(n) (store each position as hash) Code public class Solution { class PointComparer : IEqualityComparer<System.Drawing.Point> { public bool Equals(System.Drawing.Point x, System.Drawing.Point y) { return x.X == y.X && x.Y == y.Y; } public int GetHashCode(System.Drawing.Point obj) { return (obj.Y << 16) ^ obj.X; } } private HashSet<System.Drawing.Point> hashes = new HashSet<System.Drawing.Point>(new PointComparer()); private System.Drawing.Point currentPos = new System.Drawing.Point(0,0); private bool OccupyCurrentPos() { //Console.WriteLine($\"Calculated hash {hash} for position {currentPos.X}, {currentPos.Y}\"); if(hashes.Contains(currentPos)) return true; hashes.Add(currentPos); return false; } public bool IsPathCrossing(string path) { OccupyCurrentPos(); foreach(char c in path.ToLower()) { switch(c) { case 'n': currentPos.Y++; break; case 's': currentPos.Y--; break; case 'e': currentPos.X++; break; case 'w': currentPos.X--; break; } if(OccupyCurrentPos()) { //Console.WriteLine($\"Crossed at {currentPos.X},{currentPos.Y}\"); return true; } } return false; } }","title":"PathCrossing"},{"location":"PathCrossing/#intuition","text":"Implement an unoptimized solution by just recording each traveled node. NOTE: after a ton of analysis of the proposed solutions on l33tcode, I can confirm that this solution is actually quite well optimized - there does not seem to be a trick capable of detecting a crossing without recording each and every position","title":"Intuition"},{"location":"PathCrossing/#approach","text":"Record each traveled node by combining X and Y into a single number and store in a HashSet Iterate through all characters in the array until a previously traveled node is encountered, then exit.","title":"Approach"},{"location":"PathCrossing/#complexity","text":"Time complexity: O(n) (iterate through each position once) Space complexity: O(n) (store each position as hash)","title":"Complexity"},{"location":"PathCrossing/#code","text":"public class Solution { class PointComparer : IEqualityComparer<System.Drawing.Point> { public bool Equals(System.Drawing.Point x, System.Drawing.Point y) { return x.X == y.X && x.Y == y.Y; } public int GetHashCode(System.Drawing.Point obj) { return (obj.Y << 16) ^ obj.X; } } private HashSet<System.Drawing.Point> hashes = new HashSet<System.Drawing.Point>(new PointComparer()); private System.Drawing.Point currentPos = new System.Drawing.Point(0,0); private bool OccupyCurrentPos() { //Console.WriteLine($\"Calculated hash {hash} for position {currentPos.X}, {currentPos.Y}\"); if(hashes.Contains(currentPos)) return true; hashes.Add(currentPos); return false; } public bool IsPathCrossing(string path) { OccupyCurrentPos(); foreach(char c in path.ToLower()) { switch(c) { case 'n': currentPos.Y++; break; case 's': currentPos.Y--; break; case 'e': currentPos.X++; break; case 'w': currentPos.X--; break; } if(OccupyCurrentPos()) { //Console.WriteLine($\"Crossed at {currentPos.X},{currentPos.Y}\"); return true; } } return false; } }","title":"Code"},{"location":"SetMatrixZeros/","text":"https://leetcode.com/problems/set-matrix-zeroes Intuition I was careful enough to notice that the problem must be done \"in place\" , but I overcomplicated the requirements by thinking ONLY the original input matrix could be used (no additional lists could be used). Approach My original approach was to iterate through the matrix until a zero was found. Once a zero was found, I would enter a recursive function which would zero out all adjacent cells in the row & column of the \"naturally occurring\" zero, while also checking for more \"naturally occurring\" zeros. As usual, recursive functions rarely seem to be the most efficient answer with these solutions. After submitting my solution and surprisingly passing (beating about 5% of people on both time and space), I think realized the stupidly easy optimal solution. Optimization The optimal solution you see below simply iterates through the matrix to find any cells with zero, and records the column and row index, but does not modify the matrix yet. Next - as a separate step (once all zeros have been found), then the accrued list of column and row indices is used to zero-out the necessary rows and columns. Very simple and no recursion necessary. Complexity Time complexity: O(n) Space complexity: O(zr + zc) where zr is the number of rows with zeros and zc is the number of columns with zeros Code public class Solution { public void SetZeroes(int[][] matrix) { HashSet<int> zerod_rows = new HashSet<int>(); HashSet<int> zerod_cols = new HashSet<int>(); // iterate through each element for(int row=0; row<matrix.Length; row++) { for(int col=0; col<matrix[0].Length; col++) { // check if element is zero if(matrix[row][col]==0) { // record row & col zerod_rows.Add(row); zerod_cols.Add(col); } } } // apply zero to appropriate cols foreach(var col in zerod_cols) { for(int row=0; row<matrix.Length; row++) matrix[row][col] = 0; } // apply zero to appropriate rows foreach(var row in zerod_rows) { for(int col=0; col<matrix[0].Length; col++) matrix[row][col] = 0; } } }","title":"SetMatrixZeros"},{"location":"SetMatrixZeros/#intuition","text":"I was careful enough to notice that the problem must be done \"in place\" , but I overcomplicated the requirements by thinking ONLY the original input matrix could be used (no additional lists could be used).","title":"Intuition"},{"location":"SetMatrixZeros/#approach","text":"My original approach was to iterate through the matrix until a zero was found. Once a zero was found, I would enter a recursive function which would zero out all adjacent cells in the row & column of the \"naturally occurring\" zero, while also checking for more \"naturally occurring\" zeros. As usual, recursive functions rarely seem to be the most efficient answer with these solutions. After submitting my solution and surprisingly passing (beating about 5% of people on both time and space), I think realized the stupidly easy optimal solution.","title":"Approach"},{"location":"SetMatrixZeros/#optimization","text":"The optimal solution you see below simply iterates through the matrix to find any cells with zero, and records the column and row index, but does not modify the matrix yet. Next - as a separate step (once all zeros have been found), then the accrued list of column and row indices is used to zero-out the necessary rows and columns. Very simple and no recursion necessary.","title":"Optimization"},{"location":"SetMatrixZeros/#complexity","text":"Time complexity: O(n) Space complexity: O(zr + zc) where zr is the number of rows with zeros and zc is the number of columns with zeros","title":"Complexity"},{"location":"SetMatrixZeros/#code","text":"public class Solution { public void SetZeroes(int[][] matrix) { HashSet<int> zerod_rows = new HashSet<int>(); HashSet<int> zerod_cols = new HashSet<int>(); // iterate through each element for(int row=0; row<matrix.Length; row++) { for(int col=0; col<matrix[0].Length; col++) { // check if element is zero if(matrix[row][col]==0) { // record row & col zerod_rows.Add(row); zerod_cols.Add(col); } } } // apply zero to appropriate cols foreach(var col in zerod_cols) { for(int row=0; row<matrix.Length; row++) matrix[row][col] = 0; } // apply zero to appropriate rows foreach(var row in zerod_rows) { for(int col=0; col<matrix[0].Length; col++) matrix[row][col] = 0; } } }","title":"Code"},{"location":"TotalCharactersInStringAfterTransformations/","text":"https://leetcode.com/problems/total-characters-in-string-after-transformations-i Intuition My first intuition was that I could determine the output of a given letter after t iterations, independent of the other letters. (I was wrong) Approach My first approach was to try and use a combination of modulus and dividing the iteration count t by 26 to determine the end result of each letter. The goal here was to NOT iterate through t and aim for a fixed complexity rather than O(n) . In the end I found the branching logic too difficult for high iterations of t . With high enough iterations, a single letter would spawn many other letters and I could not capture this logic with a math equation. Secondly I tried counting all the letters and putting them into buckets., then performing a similar pass as previously discussed. This also did not work. Finally, after peeking at the answer, I resigned to iterating through t for O(n) complexity. I broke-down and re-wrote the answer in order to fully understand it. In the end I still wonder if there is a calculation which could capture the end state after t transformations of even a single letter, without having to \"perform the simulation\" by iterating over t . Complexity Time complexity: O(n) Space complexity: Whatever 26 letters take up + the supporting code. Fixed cost. Code public class Solution { private const int MOD = 1000000007; public ulong[] CountChars(string s) { ulong[] char_counts = new ulong[26]; foreach (char ch in s) char_counts[ch - 'a']++; return char_counts; } public int LengthAfterTransformations(string s, int t) { var char_counts = CountChars(s); /* deciphered from https://leetcode.com/problems/total-characters-in-string-after-transformations-i/?envType=daily-question&envId=2025-05-13 this solution cleverly defines letter counts based on where they could COME FROM, rather than what each letter is CONVERTED TO ...'a' can come from 'z' ...'b' can come from 'z' or 'a' ...others chars can come from their previous char this allows for a very clear formulaic approach ----------- however, it is not possible to determine all yields of a given letter and number of steps. ...for example, if provided the only input string of letter 'a' but a long number of steps 't', ...it's still difficult to determine the result ... therefore, it IS actually necessary to step through each iteration (via 't') (oh and dont forget to apply modulator to reduce number size) */ for (ulong i = 0; i < (ulong)t; ++i) { ulong[] next_counts = new ulong[26]; // 'a' only comes from 'z' next_counts[0] = char_counts[25]; // 'b' comes from 'a' and 'z' next_counts[1] = (char_counts[25] + char_counts[0]) % MOD; // remaining letters come from their previous for (ulong j = 2; j < 26; ++j) next_counts[j] = char_counts[j - 1] % MOD; char_counts = next_counts; } return (int)(char_counts.Aggregate((x,y) =>(x+y) % MOD)); } }","title":"TotalCharactersInStringAfterTransformations"},{"location":"TotalCharactersInStringAfterTransformations/#intuition","text":"My first intuition was that I could determine the output of a given letter after t iterations, independent of the other letters. (I was wrong)","title":"Intuition"},{"location":"TotalCharactersInStringAfterTransformations/#approach","text":"My first approach was to try and use a combination of modulus and dividing the iteration count t by 26 to determine the end result of each letter. The goal here was to NOT iterate through t and aim for a fixed complexity rather than O(n) . In the end I found the branching logic too difficult for high iterations of t . With high enough iterations, a single letter would spawn many other letters and I could not capture this logic with a math equation. Secondly I tried counting all the letters and putting them into buckets., then performing a similar pass as previously discussed. This also did not work. Finally, after peeking at the answer, I resigned to iterating through t for O(n) complexity. I broke-down and re-wrote the answer in order to fully understand it. In the end I still wonder if there is a calculation which could capture the end state after t transformations of even a single letter, without having to \"perform the simulation\" by iterating over t .","title":"Approach"},{"location":"TotalCharactersInStringAfterTransformations/#complexity","text":"Time complexity: O(n) Space complexity: Whatever 26 letters take up + the supporting code. Fixed cost.","title":"Complexity"},{"location":"TotalCharactersInStringAfterTransformations/#code","text":"public class Solution { private const int MOD = 1000000007; public ulong[] CountChars(string s) { ulong[] char_counts = new ulong[26]; foreach (char ch in s) char_counts[ch - 'a']++; return char_counts; } public int LengthAfterTransformations(string s, int t) { var char_counts = CountChars(s); /* deciphered from https://leetcode.com/problems/total-characters-in-string-after-transformations-i/?envType=daily-question&envId=2025-05-13 this solution cleverly defines letter counts based on where they could COME FROM, rather than what each letter is CONVERTED TO ...'a' can come from 'z' ...'b' can come from 'z' or 'a' ...others chars can come from their previous char this allows for a very clear formulaic approach ----------- however, it is not possible to determine all yields of a given letter and number of steps. ...for example, if provided the only input string of letter 'a' but a long number of steps 't', ...it's still difficult to determine the result ... therefore, it IS actually necessary to step through each iteration (via 't') (oh and dont forget to apply modulator to reduce number size) */ for (ulong i = 0; i < (ulong)t; ++i) { ulong[] next_counts = new ulong[26]; // 'a' only comes from 'z' next_counts[0] = char_counts[25]; // 'b' comes from 'a' and 'z' next_counts[1] = (char_counts[25] + char_counts[0]) % MOD; // remaining letters come from their previous for (ulong j = 2; j < 26; ++j) next_counts[j] = char_counts[j - 1] % MOD; char_counts = next_counts; } return (int)(char_counts.Aggregate((x,y) =>(x+y) % MOD)); } }","title":"Code"}]}