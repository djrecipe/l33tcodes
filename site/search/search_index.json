{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"l33tcode Solutions for JD Pierce Path-Crossing Problem https://leetcode.com/problems/path-crossing Solution Finding 3-Digit Even Numbers https://leetcode.com/problems/finding-3-digit-even-numbers Solution","title":"l33tcode Solutions for JD Pierce"},{"location":"#l33tcode-solutions-for-jd-pierce","text":"","title":"l33tcode Solutions for JD Pierce"},{"location":"#path-crossing-problem","text":"https://leetcode.com/problems/path-crossing Solution","title":"Path-Crossing Problem"},{"location":"#finding-3-digit-even-numbers","text":"https://leetcode.com/problems/finding-3-digit-even-numbers Solution","title":"Finding 3-Digit Even Numbers"},{"location":"Finding3DigitEvenNumbers/","text":"[https://leetcode.com/problems/path-crossing https://leetcode.com/problems/finding-3-digit-even-numbers Intuition My first thought was to use a sliding window to find all of the possible 3 digit groupings, then separately find each possible permutation of numbers within each grouping. This flawed first thinking stemmed from one issue off the get-go: I did NOT read the problem thorougly enough and thus I thought each group of 3 numbers had to be next to each other (consecutive). However, I later realized you could group any 3 numbers regardless of proximity, which later gave rise to the ReduceDigits() method which allows the solution to run somewhat performately. Approach Reduce digits to a maximum of 3 of each digit (3 0's, 3 1's, etc.) Find all possible unique groupings of 3 digits from the pool Check for leading zero Check last digit is even Return all even numbers that have passed all criteria Complexity Time complexity: Essentially O(n) but it's a bit of a complicated calculation - note there is an aboslute maximum of n=30 (3*10) Space complexity: Also should be linear, so O(n) Code ```csharp [] class TupleComparer : IEqualityComparer > { public bool Equals(Tuple x, Tuple y) { var x_ordered = new List (){x.Item1, x.Item2, x.Item3}; x_ordered.Sort(); var y_ordered = new List (){y.Item1, y.Item2, y.Item3}; y_ordered.Sort(); return x_ordered[0] == y_ordered[0] && x_ordered[1] == y_ordered[1] && x_ordered[2] == y_ordered[2]; } public int GetHashCode(Tuple<int,int,int> source) { int hash = 0; hash = hash ^ source.Item1.GetHashCode(); hash = hash ^ source.Item2.GetHashCode(); hash = hash ^ source.Item3.GetHashCode(); return hash; } } public class Solution { public void GetPermutations(Tuple digits, ref HashSet hashes) { if(digits.Item1 != 0) { if(digits.Item3 % 2 == 0) hashes.Add(digits.Item1 * 100 + digits.Item2 * 10 + digits.Item3); if(digits.Item2 % 2 == 0) hashes.Add(digits.Item1 * 100 + digits.Item3 * 10 + digits.Item2); } if(digits.Item2 != 0) { if(digits.Item3 % 2 == 0) hashes.Add(digits.Item2 * 100 + digits.Item1 * 10 + digits.Item3); if(digits.Item1 % 2 == 0) hashes.Add(digits.Item2 * 100 + digits.Item3 * 10 + digits.Item1); } if(digits.Item3 != 0) { if(digits.Item2 % 2 == 0) hashes.Add(digits.Item3 * 100 + digits.Item1 * 10 + digits.Item2); if(digits.Item1 % 2 == 0) hashes.Add(digits.Item3 * 100 + digits.Item2 * 10 + digits.Item1); } } public HashSet<Tuple<int,int,int>> GetGroups(int[] digits) { HashSet<Tuple<int,int,int>> hashes = new HashSet<Tuple<int,int,int>>(new TupleComparer()); for(int i=0; i<digits.Length; i++) { var item1 = digits[i]; for(int j=0; j<digits.Length; j++) { if(i==j) continue; var item2 = digits[j]; for(int k=0; k<digits.Length; k++) { if(i==k || j==k) continue; var item3 = digits[k]; Tuple<int,int,int> group = new Tuple<int,int,int>(item1, item2, item3); hashes.Add(group); } } } return hashes; } int[] ReduceDigits(int[] digits) { List<int> new_digits = new List<int>(); for(int i=0; i<10; i++) { int count = digits.Count(d => d==i); for(int j=0; j<count && j<=3; j++) { new_digits.Add(i); } } return new_digits.ToArray(); } public int[] FindEvenNumbers(int[] digits) { var new_digits = ReduceDigits(digits); var groups = GetGroups(new_digits); Console.WriteLine($\"Found {groups.Count()} groups:\"); foreach(var group in groups) Console.WriteLine($\"{group.Item1}{group.Item2}{group.Item3}\"); HashSet<int> evenNums = new HashSet<int>(); foreach(var group in groups) { GetPermutations(group, ref evenNums); } var result = evenNums.ToList(); result.Sort(); return result.ToArray(); } } ```](https://leetcode.com/problems/path-crossing) Intuition Implement an unoptimized solution by just recording each traveled node. NOTE: after a ton of analysis of the proposed solutions on l33tcode, I can confirm that this solution is actually quite well optimized - there does not seem to be a trick capable of detecting a crossing without recording each and every position Approach Record each traveled node by combining X and Y into a single number and store in a HashSet Iterate through all characters in the array until a previously traveled node is encountered, then exit. Complexity Time complexity: O(n) (iterate through each position once) Space complexity: O(n) (store each position as hash) Code public class Solution { class PointComparer : IEqualityComparer<System.Drawing.Point> { public bool Equals(System.Drawing.Point x, System.Drawing.Point y) { return x.X == y.X && x.Y == y.Y; } public int GetHashCode(System.Drawing.Point obj) { return (obj.Y << 16) ^ obj.X; } } private HashSet<System.Drawing.Point> hashes = new HashSet<System.Drawing.Point>(new PointComparer()); private System.Drawing.Point currentPos = new System.Drawing.Point(0,0); private bool OccupyCurrentPos() { //Console.WriteLine($\"Calculated hash {hash} for position {currentPos.X}, {currentPos.Y}\"); if(hashes.Contains(currentPos)) return true; hashes.Add(currentPos); return false; } public bool IsPathCrossing(string path) { OccupyCurrentPos(); foreach(char c in path.ToLower()) { switch(c) { case 'n': currentPos.Y++; break; case 's': currentPos.Y--; break; case 'e': currentPos.X++; break; case 'w': currentPos.X--; break; } if(OccupyCurrentPos()) { //Console.WriteLine($\"Crossed at {currentPos.X},{currentPos.Y}\"); return true; } } return false; } }","title":"Finding3DigitEvenNumbers"},{"location":"Finding3DigitEvenNumbers/#intuition","text":"My first thought was to use a sliding window to find all of the possible 3 digit groupings, then separately find each possible permutation of numbers within each grouping. This flawed first thinking stemmed from one issue off the get-go: I did NOT read the problem thorougly enough and thus I thought each group of 3 numbers had to be next to each other (consecutive). However, I later realized you could group any 3 numbers regardless of proximity, which later gave rise to the ReduceDigits() method which allows the solution to run somewhat performately.","title":"Intuition"},{"location":"Finding3DigitEvenNumbers/#approach","text":"Reduce digits to a maximum of 3 of each digit (3 0's, 3 1's, etc.) Find all possible unique groupings of 3 digits from the pool Check for leading zero Check last digit is even Return all even numbers that have passed all criteria","title":"Approach"},{"location":"Finding3DigitEvenNumbers/#complexity","text":"Time complexity: Essentially O(n) but it's a bit of a complicated calculation - note there is an aboslute maximum of n=30 (3*10) Space complexity: Also should be linear, so O(n)","title":"Complexity"},{"location":"Finding3DigitEvenNumbers/#code","text":"```csharp [] class TupleComparer : IEqualityComparer > { public bool Equals(Tuple x, Tuple y) { var x_ordered = new List (){x.Item1, x.Item2, x.Item3}; x_ordered.Sort(); var y_ordered = new List (){y.Item1, y.Item2, y.Item3}; y_ordered.Sort(); return x_ordered[0] == y_ordered[0] && x_ordered[1] == y_ordered[1] && x_ordered[2] == y_ordered[2]; } public int GetHashCode(Tuple<int,int,int> source) { int hash = 0; hash = hash ^ source.Item1.GetHashCode(); hash = hash ^ source.Item2.GetHashCode(); hash = hash ^ source.Item3.GetHashCode(); return hash; } } public class Solution { public void GetPermutations(Tuple digits, ref HashSet hashes) { if(digits.Item1 != 0) { if(digits.Item3 % 2 == 0) hashes.Add(digits.Item1 * 100 + digits.Item2 * 10 + digits.Item3); if(digits.Item2 % 2 == 0) hashes.Add(digits.Item1 * 100 + digits.Item3 * 10 + digits.Item2); } if(digits.Item2 != 0) { if(digits.Item3 % 2 == 0) hashes.Add(digits.Item2 * 100 + digits.Item1 * 10 + digits.Item3); if(digits.Item1 % 2 == 0) hashes.Add(digits.Item2 * 100 + digits.Item3 * 10 + digits.Item1); } if(digits.Item3 != 0) { if(digits.Item2 % 2 == 0) hashes.Add(digits.Item3 * 100 + digits.Item1 * 10 + digits.Item2); if(digits.Item1 % 2 == 0) hashes.Add(digits.Item3 * 100 + digits.Item2 * 10 + digits.Item1); } } public HashSet<Tuple<int,int,int>> GetGroups(int[] digits) { HashSet<Tuple<int,int,int>> hashes = new HashSet<Tuple<int,int,int>>(new TupleComparer()); for(int i=0; i<digits.Length; i++) { var item1 = digits[i]; for(int j=0; j<digits.Length; j++) { if(i==j) continue; var item2 = digits[j]; for(int k=0; k<digits.Length; k++) { if(i==k || j==k) continue; var item3 = digits[k]; Tuple<int,int,int> group = new Tuple<int,int,int>(item1, item2, item3); hashes.Add(group); } } } return hashes; } int[] ReduceDigits(int[] digits) { List<int> new_digits = new List<int>(); for(int i=0; i<10; i++) { int count = digits.Count(d => d==i); for(int j=0; j<count && j<=3; j++) { new_digits.Add(i); } } return new_digits.ToArray(); } public int[] FindEvenNumbers(int[] digits) { var new_digits = ReduceDigits(digits); var groups = GetGroups(new_digits); Console.WriteLine($\"Found {groups.Count()} groups:\"); foreach(var group in groups) Console.WriteLine($\"{group.Item1}{group.Item2}{group.Item3}\"); HashSet<int> evenNums = new HashSet<int>(); foreach(var group in groups) { GetPermutations(group, ref evenNums); } var result = evenNums.ToList(); result.Sort(); return result.ToArray(); } } ```](https://leetcode.com/problems/path-crossing)","title":"Code"},{"location":"Finding3DigitEvenNumbers/#intuition_1","text":"Implement an unoptimized solution by just recording each traveled node. NOTE: after a ton of analysis of the proposed solutions on l33tcode, I can confirm that this solution is actually quite well optimized - there does not seem to be a trick capable of detecting a crossing without recording each and every position","title":"Intuition"},{"location":"Finding3DigitEvenNumbers/#approach_1","text":"Record each traveled node by combining X and Y into a single number and store in a HashSet Iterate through all characters in the array until a previously traveled node is encountered, then exit.","title":"Approach"},{"location":"Finding3DigitEvenNumbers/#complexity_1","text":"Time complexity: O(n) (iterate through each position once) Space complexity: O(n) (store each position as hash)","title":"Complexity"},{"location":"Finding3DigitEvenNumbers/#code_1","text":"public class Solution { class PointComparer : IEqualityComparer<System.Drawing.Point> { public bool Equals(System.Drawing.Point x, System.Drawing.Point y) { return x.X == y.X && x.Y == y.Y; } public int GetHashCode(System.Drawing.Point obj) { return (obj.Y << 16) ^ obj.X; } } private HashSet<System.Drawing.Point> hashes = new HashSet<System.Drawing.Point>(new PointComparer()); private System.Drawing.Point currentPos = new System.Drawing.Point(0,0); private bool OccupyCurrentPos() { //Console.WriteLine($\"Calculated hash {hash} for position {currentPos.X}, {currentPos.Y}\"); if(hashes.Contains(currentPos)) return true; hashes.Add(currentPos); return false; } public bool IsPathCrossing(string path) { OccupyCurrentPos(); foreach(char c in path.ToLower()) { switch(c) { case 'n': currentPos.Y++; break; case 's': currentPos.Y--; break; case 'e': currentPos.X++; break; case 'w': currentPos.X--; break; } if(OccupyCurrentPos()) { //Console.WriteLine($\"Crossed at {currentPos.X},{currentPos.Y}\"); return true; } } return false; } }","title":"Code"},{"location":"PathCrossing/","text":"https://leetcode.com/problems/path-crossing Intuition Implement an unoptimized solution by just recording each traveled node. NOTE: after a ton of analysis of the proposed solutions on l33tcode, I can confirm that this solution is actually quite well optimized - there does not seem to be a trick capable of detecting a crossing without recording each and every position Approach Record each traveled node by combining X and Y into a single number and store in a HashSet Iterate through all characters in the array until a previously traveled node is encountered, then exit. Complexity Time complexity: O(n) (iterate through each position once) Space complexity: O(n) (store each position as hash) Code public class Solution { class PointComparer : IEqualityComparer<System.Drawing.Point> { public bool Equals(System.Drawing.Point x, System.Drawing.Point y) { return x.X == y.X && x.Y == y.Y; } public int GetHashCode(System.Drawing.Point obj) { return (obj.Y << 16) ^ obj.X; } } private HashSet<System.Drawing.Point> hashes = new HashSet<System.Drawing.Point>(new PointComparer()); private System.Drawing.Point currentPos = new System.Drawing.Point(0,0); private bool OccupyCurrentPos() { //Console.WriteLine($\"Calculated hash {hash} for position {currentPos.X}, {currentPos.Y}\"); if(hashes.Contains(currentPos)) return true; hashes.Add(currentPos); return false; } public bool IsPathCrossing(string path) { OccupyCurrentPos(); foreach(char c in path.ToLower()) { switch(c) { case 'n': currentPos.Y++; break; case 's': currentPos.Y--; break; case 'e': currentPos.X++; break; case 'w': currentPos.X--; break; } if(OccupyCurrentPos()) { //Console.WriteLine($\"Crossed at {currentPos.X},{currentPos.Y}\"); return true; } } return false; } }","title":"PathCrossing"},{"location":"PathCrossing/#intuition","text":"Implement an unoptimized solution by just recording each traveled node. NOTE: after a ton of analysis of the proposed solutions on l33tcode, I can confirm that this solution is actually quite well optimized - there does not seem to be a trick capable of detecting a crossing without recording each and every position","title":"Intuition"},{"location":"PathCrossing/#approach","text":"Record each traveled node by combining X and Y into a single number and store in a HashSet Iterate through all characters in the array until a previously traveled node is encountered, then exit.","title":"Approach"},{"location":"PathCrossing/#complexity","text":"Time complexity: O(n) (iterate through each position once) Space complexity: O(n) (store each position as hash)","title":"Complexity"},{"location":"PathCrossing/#code","text":"public class Solution { class PointComparer : IEqualityComparer<System.Drawing.Point> { public bool Equals(System.Drawing.Point x, System.Drawing.Point y) { return x.X == y.X && x.Y == y.Y; } public int GetHashCode(System.Drawing.Point obj) { return (obj.Y << 16) ^ obj.X; } } private HashSet<System.Drawing.Point> hashes = new HashSet<System.Drawing.Point>(new PointComparer()); private System.Drawing.Point currentPos = new System.Drawing.Point(0,0); private bool OccupyCurrentPos() { //Console.WriteLine($\"Calculated hash {hash} for position {currentPos.X}, {currentPos.Y}\"); if(hashes.Contains(currentPos)) return true; hashes.Add(currentPos); return false; } public bool IsPathCrossing(string path) { OccupyCurrentPos(); foreach(char c in path.ToLower()) { switch(c) { case 'n': currentPos.Y++; break; case 's': currentPos.Y--; break; case 'e': currentPos.X++; break; case 'w': currentPos.X--; break; } if(OccupyCurrentPos()) { //Console.WriteLine($\"Crossed at {currentPos.X},{currentPos.Y}\"); return true; } } return false; } }","title":"Code"}]}